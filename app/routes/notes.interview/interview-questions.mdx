---
title: "Programming Interview Questions"
slug: questions/longest-increasing-subsequence
date: "2020-08-16"
categories: interview
---

## Question
Given an integer array nums, return the length of the longest increasing subsequence.

Example:

```js
> increasingSubsequence([10, 9, 2, 3, 7, 101, 18])
> 4
```

```js
> increasingSubsequence([4, 4, 4, 4, 3])
> 1
```

```js
> increasingSubsequence([0, 1, 0, 3, 2, 3])
> 4
```

```js
> increasingSubsequence([10, 9, 2, 5, 3, 7, 101, 18])
> 4
```


*Subsequence*: A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements.

*Increasing Subsequence*: A subsequence where each element is greater than the previous one.

*Non-Contiguous*: The elements of the subsequence do not have to be contiguous in the original array.


<details>
<summary>Solution</summary>

### Attempt 1

_This was done without understanding the problem statement properly._

```js

function increasingSubsequence(nums) {
  let maxSeries = [];
  let max = 1;
  for (let i = 1; i < nums.length; i++) {
    if(nums[i] > nums[i - 1]) {
      max++;
    } else if(i == nums.length -1) {
      maxSeries.push(max);
    } else {
      maxSeries.push(max);
      max = 1;
    }
  }
  return Math.max(...maxSeries);
}

```

- function finds the longest consecutive increasing subsequence, not the longest increasing subsequence in general. It only compares adjacent elements.

- solution has a time complexity of O(n) and space complexity of O(n)

- It will miss non-consecutive increasing subsequences.

### Attempt 2
 
_With the help of chatgpt_

```javascript
function increasingSubsequence(nums) {
    if (nums.length === 0) {
        return 0;
    }
    
    const n = nums.length;
    const dp = new Array(n).fill(1);
    
    for (let i = 1; i < n; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    
    return Math.max(...dp);
}
```

This JavaScript implementation follows the same logic as the Python version:

1. We first check if the input array is empty. If so, we return 0.

2. We create a `dp` array of the same length as the input array, initialized with all 1s.

3. We use nested loops to compare each element with all previous elements.

4. If we find a smaller previous element, we update the current dp value if necessary.

5. Finally, we return the maximum value in the dp array, which represents the length of the longest increasing subsequence.

The time and space complexities remain the same: O(n^2) time and O(n) space, where n is the length of the input array.

</details>

## Question 

Define a FruitStand class that allows you to add different types of fruits with their quantities and prices, update them, and calculate the total value of all the fruits in the stand. 

Implement the following methods: 
- `addFruit(name, quantity, price)`
- `updateQuantity(name, quantity)` 
- `totalValue()`

Example usage:

```js
// Create a new fruit stand
let stand = FruitStand()

// Add fruits to the stand
stand.addFruit("apple", 10, 0.5)
stand.addFruit("banana", 5, 0.2)
stand.addFruit("cherry", 20, 0.1)

// Update the quantity of an existing fruit
stand.updateQuantity("banana", 10)

// Calculate the total value of all fruits in the stand
console.log(stand.totalValue())
```


<details>
<summary>Solution</summary>

```js

class FruitStand {
  fruits = {};
  addFruit(name, quantity, price){
    this.fruits[name] = {quantity, price};
  }
  updateQuantity(name, quantity){
    this.fruits[name].quantity = quantity;
  }
  totalValue(){
    return Object.values(this.fruits).reduce((total, fruit) => total + fruit.quantity * fruit.price, 0);
  }
}
```
</details>

## Questions

Write a function that takes an array of integers representing the number of flowers planted in a line, and an integer k representing the number of additional flowers you want to plant. Return whether it's possible to plant all k flowers without planting any two flowers adjacent to each other.

Example:

```js
> canPlantFlowers([1, 0, 0, 0, 1], 1)
> true // you can plant 1 flower between the others

> canPlantFlowers([1, 0, 0, 0, 1], 2)
> false

> canPlantFlowers([0, 0, 0, 0, 0], 3)
> true

> canPlantFlowers([1, 0, 1, 0, 1], 1)
> false
```


<details>
<summary>Solution</summary>

```js
function canPlantFlowers(flowers, k) {
    let count = 0;

    for(i = 0; i < flowers.length; i++) {
        if(flowers[i] == 0) {
            prevEmpty = (i === 0) || (flowers[i-1] === 0)
            nextEmpty = (i === flowers.length-1) || (flowers[i+1] === 0)
            if(prevEmpty && nextEmpty) {
                flowers[i] = 1;
                count++;
            }
            if(count >= k) return true
        } 
    }
    return count >= k;
}
```
</details>

## Question

Write a function that takes a list of names and returns the names sorted by the number of vowels in each name in descending order. If two names have the same number of vowels, sort them alphabetically.


Example:

```js
> sortNames(["Goku", "Vegeta", "Piccolo", "Gohan"])
> ["Piccolo", "Vegeta", "Gohan", "Goku"]

> sortNames(["Edward", "Alphonse", "Roy", "Winry"])
> ["Alphonse", "Edward", "Winry", "Roy"]
```